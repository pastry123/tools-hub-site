import { useState, useRef, useEffect } from "react";
import { PDFDocument, rgb } from "pdf-lib";
import { Button } from "@/components/ui/button";

export default function PDFEditor() {
  const [pdfDoc, setPdfDoc] = useState(null);
  const [url, setUrl] = useState(null);
  const [pageIndex, setPageIndex] = useState(0);
  const fileInputRef = useRef(null);
  const overlayRef = useRef(null);
  const [transparentField, setTransparentField] = useState(false);
  const [fields, setFields] = useState([]);
  const [images, setImages] = useState([]);
  const [selectedId, setSelectedId] = useState(null);

  async function loadPdf(e) {
    const file = e.target.files[0];
    const arrayBuffer = await file.arrayBuffer();
    const loadedPdf = await PDFDocument.load(arrayBuffer, {
      updateMetadata: true,
      ignoreEncryption: true,
    });
    setPdfDoc(loadedPdf);
    const blob = new Blob([arrayBuffer], { type: "application/pdf" });
    setUrl(URL.createObjectURL(blob));
    setPageIndex(0);
  }

  function addDraggableText() {
    const id = Date.now();
    setFields([...fields, { id, x: 100, y: 100, text: "Edit me", width: 150, height: 30, page: pageIndex }]);
  }

  function updateField(id, updates) {
    setFields(fields.map(f => f.id === id ? { ...f, ...updates } : f));
  }

  function deleteSelected() {
    setFields(fields.filter(f => f.id !== selectedId));
    setImages(images.filter((_, i) => i !== selectedId));
    setSelectedId(null);
  }

  function startDrag(e, id) {
    setSelectedId(id);
    const offsetX = e.nativeEvent.offsetX;
    const offsetY = e.nativeEvent.offsetY;
    const onMove = moveEvent => {
      updateField(id, {
        x: moveEvent.clientX - offsetX,
        y: moveEvent.clientY - offsetY,
      });
    };
    const onUp = () => {
      document.removeEventListener("mousemove", onMove);
      document.removeEventListener("mouseup", onUp);
    };
    document.addEventListener("mousemove", onMove);
    document.addEventListener("mouseup", onUp);
  }

  async function renderToPdf() {
    if (!pdfDoc) return;
    const page = pdfDoc.getPages()[pageIndex];
    fields.filter(f => f.page === pageIndex).forEach(field => {
      page.drawText(field.text, {
        x: field.x,
        y: page.getHeight() - field.y - field.height,
        size: 12,
        color: rgb(0, 0, 0),
        ...(transparentField ? {} : { backgroundColor: rgb(1, 1, 1) }),
      });
    });

    for (const img of images.filter(i => i.page === pageIndex)) {
      const imageBytes = await fetch(img.url).then(res => res.arrayBuffer());
      let embeddedImg;
      if (img.type === "image/jpeg") {
        embeddedImg = await pdfDoc.embedJpg(imageBytes);
      } else {
        embeddedImg = await pdfDoc.embedPng(imageBytes);
      }
      page.drawImage(embeddedImg, {
        x: img.x,
        y: page.getHeight() - img.y - img.height,
        width: img.width,
        height: img.height,
      });
    }

    const pdfBytes = await pdfDoc.save();
    const blob = new Blob([pdfBytes], { type: "application/pdf" });
    setUrl(URL.createObjectURL(blob));
    setFields([]);
  }

  function addImageOverlay(file) {
    const url = URL.createObjectURL(file);
    const id = Date.now();
    setImages([...images, { id, url, x: 100, y: 100, width: 150, height: 150, type: file.type, page: pageIndex }]);
  }

  function updateImage(id, updates) {
    const updated = images.map(img => img.id === id ? { ...img, ...updates } : img);
    setImages(updated);
  }

  function startImageDrag(e, id) {
    setSelectedId(id);
    const offsetX = e.nativeEvent.offsetX;
    const offsetY = e.nativeEvent.offsetY;
    const onMove = moveEvent => {
      updateImage(id, {
        x: moveEvent.clientX - offsetX,
        y: moveEvent.clientY - offsetY,
      });
    };
    const onUp = () => {
      document.removeEventListener("mousemove", onMove);
      document.removeEventListener("mouseup", onUp);
    };
    document.addEventListener("mousemove", onMove);
    document.addEventListener("mouseup", onUp);
  }

  async function downloadPdf() {
    if (!pdfDoc) return;
    const pdfBytes = await pdfDoc.save();
    const blob = new Blob([pdfBytes], { type: "application/pdf" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "edited.pdf";
    a.click();
  }

  const nextPage = () => {
    if (pdfDoc && pageIndex < pdfDoc.getPages().length - 1) {
      setPageIndex(pageIndex + 1);
    }
  };

  const prevPage = () => {
    if (pdfDoc && pageIndex > 0) {
      setPageIndex(pageIndex - 1);
    }
  };

  return (
    <div className="p-6 space-y-4">
      <h1 className="text-2xl font-bold">ToolHub PDF Editor</h1>
      <input type="file" accept="application/pdf" onChange={loadPdf} ref={fileInputRef} />
      <div className="relative w-full h-[500px] border">
        {url && (
          <>
            <iframe
              src={`${url}#page=${pageIndex + 1}`}
              className="w-full h-full absolute z-0"
              title="PDF Preview"
            ></iframe>
            <div ref={overlayRef} className="absolute inset-0 z-10">
              {fields.filter(f => f.page === pageIndex).map(field => (
                <textarea
                  key={field.id}
                  value={field.text}
                  onChange={e => updateField(field.id, { text: e.target.value })}
                  onMouseDown={e => startDrag(e, field.id)}
                  style={{
                    position: "absolute",
                    left: field.x,
                    top: field.y,
                    width: field.width,
                    height: field.height,
                    background: transparentField ? "transparent" : "white",
                    border: "1px solid #aaa",
                    resize: "both",
                  }}
                />
              ))}
              {images.filter(i => i.page === pageIndex).map(img => (
                <img
                  key={img.id}
                  src={img.url}
                  onMouseDown={e => startImageDrag(e, img.id)}
                  style={{
                    position: "absolute",
                    left: img.x,
                    top: img.y,
                    width: img.width,
                    height: img.height,
                    cursor: "move",
                  }}
                  draggable={false}
                />
              ))}
            </div>
          </>
        )}
      </div>
      <div className="space-x-2">
        <Button onClick={addDraggableText}>Add Editable Text</Button>
        <Button onClick={renderToPdf}>Apply Changes to PDF</Button>
        <label className="cursor-pointer inline-block">
          <span className="px-3 py-2 bg-gray-200 rounded">Add Image</span>
          <input
            type="file"
            accept="image/png, image/jpeg"
            className="hidden"
            onChange={e => addImageOverlay(e.target.files[0])}
          />
        </label>
        <Button onClick={downloadPdf}>Download PDF</Button>
        <Button onClick={deleteSelected} variant="destructive">Delete Selected</Button>
      </div>
      <div className="flex gap-2 items-center">
        <Button onClick={prevPage} disabled={pageIndex === 0}>Previous Page</Button>
        <Button onClick={nextPage} disabled={pdfDoc && pageIndex >= pdfDoc.getPages().length - 1}>Next Page</Button>
        <span>Page {pageIndex + 1}</span>
      </div>
      <label className="block pt-2">
        <input
          type="checkbox"
          checked={transparentField}
          onChange={(e) => setTransparentField(e.target.checked)}
          className="mr-2"
        />
        Transparent Background
      </label>
    </div>
  );
}